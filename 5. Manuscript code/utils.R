

#####################################################################################################################
#                                                Packages & Data Settings                                           #
#####################################################################################################################

# Load used libraries
source("2. Cell-type analysis/utils/load.code.env.R")
invisible(lapply(c("tidyverse","reshape2","ggplot2","cowplot","dplyr","tibble","ComplexHeatmap","reticulate","anndata",
                   "patchwork","colorspace","ggrepel","rhdf5", "ggnewscale","gg3D"), library, character.only = T))

# Load literature cell annotation signatures
source("2. Cell-type analysis/utils/signatures.R")

# Base directory for saving figure panels 
panel.path <- "5. Manuscript code/graphs"

# Loading results of post-atlas analyses including: 
# subpopulation proportion matrix, trait associations and meta-analysis, 
# cellular landscape, trait/subpopulation dynamics, communities
# This data file is generated by BEYOND files 1-3
data <- anndata::read_h5ad("2. Cell-type analysis/data/subpopulation.proportions.h5ad")

state.dynamics.sets <- list(
  list(Ast.1="#386350", Mic.2="#7BB0DF", Oli.3 = "#882D71"),
  list(Mic.12="#386350", Mic.13="#882D71"),
  list(OPC.1="#386350", Oli.6 = "#7BB0DF", Ast.3="#882D71"),
  list(Oli.7="#386350", Ast.10="#882D71"),
  list(Ast.5="#882D71",OPC.3="#386350"),
  list(Mic.6="#882D71", Mic.7="#386350"))

comm.cols <- list(C1="#00C992", C1.1="#00C992", C1.2="#008A69", 
                  C2="#882D71", C2.1="#008A69", C2.2="#7BB0DF", C2.3="#882D71", 
                  C3="#DB5829")

# General atlas information for subpopulation plotting order and grouping, as well as additional genes to be added to top DEGs dotplot.
atlas <- list(
  microglia = list(
    state.order = c(paste0("Mic.", 1:16), "Macrophages", "Monocytes"),
    main.group  = c("Proliferative", rep("Homeostatic", 4), rep("Reactive", 3), rep("Redox", 2), rep("Disease", 3), rep("Other", 3), rep("Immune", 2)),
    genes = list(
      `1`=c("TOP2A"),
      `2`=c("ARHGAP22", "CX3CR1", "P2RY12"),
      `3`=c("CD14", "IL17RA", "IL1B", "IL4R", "LRKK2", "PTPRC", "SPP1", "TLR2", "TMEM163", "TNFRSF1B"),
      `4`=c("FTH1", "FTL"),
      `5`=c("ABCA1", "APOE", "ATG7", "CCND3", "CXCR4", "DNAJB1", "DNAJB6", "TPRG1","GPNMB","PTPRG", "ITPR1", "ITPR2", "MSR1", "NLRP1", "TGFBR2", "TREM2"),
      `6`=c("IFIH1", "IFIT2", "IFIT3", "MX2", "OAS1", "OAS2", "OAS3", "PNPT1"),
      `7`=c("CCL3", "CCL3L1", "CCL4", "ITGAX", "LYN", "NFKB1", "NFKBID", "PIK3R1", "RUNX1")
    )
  ),
  astrocytes = list(
    state.order = paste0("Ast.", 1:10),
    main.group  = c(rep("Homeostatic", 3), rep("Reactive", 3), "Interferon", rep("Stress", 3)),
    genes = list(
      `1-3`=c("EPHB1", "GABAR2", "GRM3", "SLC1A2"),
      `3`=c("PINK1", "YWHAH", "YWHAG", "RPL13"),
      `4-5`=c("GFAP"),
      `4`=c("GRIA1", "GRID2", "VCAN"),
      `5`=c("FGF2", "FGFR2", "IGFBP7", "ITGB1", "OSMR", "SERPINA3"),
      `7`=c("IFI6", "IFIT1", "IFIT3"),
      `8`=c("ABCA1", "HSP90AA1", "HSPA9", "JUN", "LDLR", "NR4A2", "NR4A3", "NTRK2", "SLC4A4", "SLC7A11", "TJP1"),
      `9`=c("APOE", "CAMK2D", "DNAJB1", "DNAJB6", "FKBP4", "FTH1", "FTL", "SOD1"),
      `10`=c("CSPG5", "GJA1", "MT1E", "MT1F", "MT1G", "PLXNB1", "SLC30A1", "SLC38A2", "SLC39A12")
    )
  ),
  oligodendroglia = list(
    state.order = c(paste0("OPC.", 1:3), "MFOL", "COP", paste0("Oli.", 1:12)),
    main.group = c(rep("OPC", 5), rep("Oli", 12)),
    genes = list(
      `1`=c("PINK1", "TOMM20", "TOMM7"),
      `opc3`=c("SERPINA3", "OSMR"),
      `mfol`=c("ABCA2", "CNTN2"),
      `cop`=c("SOX10", "SOX6", "SOX8", "TNFRSF21", "ZNF365"),
      `7`=c("QDPR", "DPYD", "S100A6", "SEMA3C", "SLC38A2"),
      `8`=c("DNAJB1", "DNAJB6", "DNAJC1", "HSPA1A", "HSPA1B", "HSPA4L", "HSPH1", "PTGES3")
    )
  ),
  endo = list(
    state.order = c(paste0("End.", 1:5), "Arteriole", "Venule", "Peri.1", "Peri.2","SMC.1","SMC.2", paste0("Fib.", 1:3)),
    main.group = c(rep("Endothelial", 7), rep("Pericytes", 2), rep("SMC", 2), rep("Fibroblast", 3))
  ),
  excitatory = list(
    state.order = paste0("Exc.", 1:16),
    main.group = rep("excitatory", 16)
  ),
  inhibitory = list(
    state.order = paste0("Inh.", 1:16),
    main.group = rep("inhibitory", 16)
  )
)




#####################################################################################################################
#                                              General Plotting Settings                                            #
#####################################################################################################################

# Color scales
blue2red <- colorRampPalette(c("midnightblue","#003BC0","#6689d9","white","#eb8694","#D80D29","firebrick4"))
green2purple <- colorRampPalette(c("darkgreen","white","darkorchid4"))
green2purple.less.white <- colorRampPalette(c("darkgreen","#5F9E5F","white","#A074B6","darkorchid4"))
grey2purple <- colorRampPalette(c("grey80","#8ecee2","#A074B6","darkorchid4"))

# plot themes 
no.labs <- labs(x=NULL, y=NULL, color=NULL, fill=NULL)
no.axes <- theme(axis.text = element_blank(),
                 axis.ticks = element_blank(),
                 axis.line = element_blank())
theme_embedding <- theme_classic() + no.axes

# standard plot sizes
embed.width <- embed.height <- 5
embed.width.small <- embed.height.small <- 2.5


# Plot text and color for AD-related traits
AD.traits        <- c(sqrt.amyloid_mf="neocortical amyloid", sqrt.tangles_mf="neocortical tangles", cogng_demog_slope="cognitive decline rate")
AD.traits.colors <- c(sqrt.amyloid_mf="midnightblue", sqrt.tangles_mf="olivedrab4", cogng_demog_slope="firebrick3")

AD.traits.cat        <- c(ceradsc="CERAD", braaksc="Braak", cogdx_ad="AD dementia")
AD.traits.colors.cat <- c(ceradsc="midnightblue", braaksc="olivedrab4",cogdx_ad="firebrick3")




#####################################################################################################################
#                                           Atlas-related Plotting Settings                                         #
#####################################################################################################################
# Settings for accessing atlas data
# For details see 2. Cell-type analysis/aggregate.cell.type.data.R
aggregated.data <- "2. Cell-type analysis/data/DLPFC.Green.atlas.h5"
mapping <- setNames(h5read(aggregated.data, "index")$values, h5read(aggregated.data, "index")$ind)

# Load nuclei annotations and specify grouping of states
annotations <- h5read(aggregated.data, "annotations") %>% tibble::column_to_rownames("cell") 

# Order cell groups descending by number of nuclei
annotations$grouping.by <- factor(annotations$grouping.by, 
                                  levels=annotations %>% count(grouping.by) %>% arrange(desc(n)) %>% pull(grouping.by), ordered = T)

# state-group mapping
states <- annotations %>% dplyr::select(state, grouping.by) %>% unique() %>% `rownames<-`(NULL) %>% filter(state!="NA") %>% tibble::column_to_rownames("state")

# Color settings for cell states
cell.group.color = c(
  "Excitatory Neurons" = "midnightblue",
  "Inhibitory Neurons" = "#DB5928",
  "Oligodendrocytes"   = "darkgreen",
  "Astrocyte"          = "darkorchid4",
  "Microglia"          = "firebrick4",
  "OPCs"               = "#386350",
  "Vascular Niche"     = "darkgoldenrod")

joint.state.colors <- unlist(lapply(names(cell.group.color), function(c) {
  s <- rownames(states)[states$group == c]
  setNames(colorRampPalette(colorRampPalette(c("white", cell.group.color[[c]]))(3)[2:3])(length(s)), sample(s))
}))

colorRange <- function(col)
  colorRampPalette( colorRampPalette(c("white", col))(3)[2:3] )

# State colors are used for UMAP point colors
state.colors <- list(
  microglia=c(
    colorRange("darkgreen")(5) %>% `names<-`(paste0("Mic.",c(5,3,9,4,2))),
    colorRange("darkorchid4")(5) %>% `names<-`(paste0("Mic.",c(6,11,8,10,7))),
    colorRange("#8C3819")(4) %>% `names<-`(paste0("Mic.",c(13,15,14,12))),
    colorRange("midnightblue")(4) %>% `names<-`(c("Monocytes","Macrophages","Mic.16","Mic.1"))
  ),
  astrocytes=c(
    colorRange("darkgreen")(3) %>% `names<-`(paste0("Ast.",c(1,2,3))),
    colorRange("darkorchid4")(4) %>% `names<-`(paste0("Ast.",c(4,7,6,5))),
    colorRange("#8C3819")(3) %>% `names<-`(paste0("Ast.",8:10))
  ),
  inhibitory=c(
    colorRange("darkgreen")(5) %>% `names<-`(paste0("Inh.",c(2,3,4,8,12))),
    colorRange("darkorchid4")(3) %>% `names<-`(paste0("Inh.",9:11)),
    colorRange("midnightblue")(4) %>% `names<-`(paste0("Inh.", c(1,6,5,7))),
    colorRange("#8C3819")(4) %>% `names<-`(paste0("Inh.",c(16,13,15,14)))
  ),
  endo=c(
    colorRange("darkorchid4")(5) %>% `names<-`(c("Venule","Arteriole","End.2","End.4","End.5")),
    colorRange("darkgreen")(4) %>% `names<-`(c("Peri.1","Peri.2","SMC.1","SMC.2")),
    colorRange("midnightblue")(7) %>% `names<-`(c("Fib.2","Erythrocytes","Fib.3","Neutrophils","Fib.1", "NK Cells","CD8+ T Cells")),
    colorRange("#8C3819")(2) %>% `names<-`(paste0("End.",c(1,3)))
  ),
  excitatory=c(
    colorRampPalette(c(colorRange("darkorchid4")(2), colorRange("darkgreen")(2)))(10) %>% `names<-`(paste0("Exc.", c(2,1,3:8,11,9))),
    colorRange("midnightblue")(6) %>% `names<-`(paste0("Exc.",c(10,12:16)))
  ),
  oligodendroglia=c(
    colorRange("darkgreen")(4) %>% `names<-`(paste0("Oli.", c(5,4,1,3))),
    colorRange("darkorchid4")(5) %>% `names<-`(c("MFOL","COP","OPC.3","Oli.2","Oli.8")),
    colorRange("midnightblue")(5) %>% `names<-`(c(paste0("Oli.",9:12),"OPC.2")),
    colorRange("#8C3819")(3) %>% `names<-`(c("OPC.1","Oli.6","Oli.7"))
  )
)





#####################################################################################################################
#                                              Plotting Utils Functions                                             #
#####################################################################################################################

#' ComplexHeatmap wrapper for plotting heatmaps/dotplots from a given dataframe
#'
#' @param df dataframe to plot heatmap of
#' @param rows.by dataframe's column number or name whose values are used as the heatmap rows
#' @param columns.by dataframe's column number or name whose values are use as the heatmap columns
#' @param color.by dataframe's column number or name whose values are used for heatmap's color scale. 
#'    An expression over a column can also be passed. For example `-log(pval)` for `pval` a column in `df`
#' @param size.by dataframe's column number or name. If `size.by=NULL` plots a standard heatmap, otherwise a 
#'    dotplot with dot size specified by data in given column.
gheatmap <- function(df, rows.by=1, columns.by=2, color.by=3, size.by=NULL,
                     scale.by=c("","row","col"),
                     row.order=NULL, column.order=NULL,
                     cols=blue2red,
                     size.factor=1., 
                     size.by.round=2,
                     annotations=function(rows, cols) list(), 
                     row_labels=function(rows) rows,
                     column_labels=function(cols) cols,
                     ...) {
  scale.by = match.arg(scale.by)
  #TODO - support multiple gene lists and/or repeated gene names
  
  # Add columns as specified by function variables being a column index, name or expression
  for(p in c("rows.by", "columns.by")) {
    if (is.numeric(get(p)))
      assign(p, colnames(df)[get(p)])
    df <- dplyr::rename(df, {{p}}:=get(p))
  }
  
  # For color/size parameters support the use of expressions over one or many of the dataframes columns
  for(p in c("color.by","size.by")) {
    if(!is.null(get(p))) {
      if (is.numeric(get(p)))
        assign(p, colnames(df)[get(p)])
      
      used.cols <- names(base::Filter(isTRUE, sapply(colnames(df), grepl, get(p))))
      df <- df %>% dplyr::rowwise() %>% dplyr::mutate_at(used.cols, ~eval(parse(text=.)))
      df <- dplyr::mutate(df, {{p}} := eval(parse(text=get(p))))
    }
  }
  rm(p)

  # Create values matrix
  vals <- tidyr::pivot_wider(df, id_cols = "rows.by", names_from = "columns.by", values_from = "color.by", values_fill = 0) %>% tibble::column_to_rownames("rows.by") %>% as.matrix()

  # Apply row/column ordering
  if(!is.null(row.order)) { 
    row.order <- sapply(row.order, function(v) intersect(v, rownames(vals)))
    vals <- vals[unlist(row.order),] 
  }
  if(!is.null(column.order)) { 
    column.order <- sapply(column.order, function(v) intersect(v, colnames(vals)))
    vals <- vals[,unlist(column.order)] 
  }
  
  # Scaling of matrices
  if(scale.by == "col") vals <- scale(vals)
  if(scale.by == "row") vals <- t(scale(t(vals)))

  # Specify color scale for plot
  if(scale.by == "")
    col.vals <- seq(min(vals, na.rm=T), max(vals, na.rm=T), length.out=21)
  else {
    v <- max(abs(vals), na.rm = T)
    col.vals <- c(seq(-v, 0, length.out=11), seq(0, v, length.out=11)[-1])
  }
    
  col.fun  <- circlize::colorRamp2(col.vals, cols(length(col.vals)))
  
  # If `size` is specified create dotplot instead of heatmap
  if(!is.null(size.by)) {
    sizes <- tidyr::pivot_wider(df, id_cols = "rows.by", names_from = "columns.by", values_from = "size.by", values_fill = 0) %>% column_to_rownames("rows.by") %>% as.matrix()
    sizes <- sizes / max(sizes)
    
    if(!is.null(row.order)) sizes <- sizes[unlist(row.order),]
    if(!is.null(column.order)) sizes <- sizes[,unlist(column.order)]
    
    layer_fun = function(j, i, x, y, w, h, fill) {
      grid.rect(x=x, y=y, width=w, height=h, gp=gpar(col = NA, fill = NA))
      grid.circle(x=x,y=y,r=pindex(sizes, i, j)*size.factor * unit(2, "mm"), gp = gpar(fill = col.fun(pindex(vals, i, j)), col = NA))}
    rect_gp = gpar(type = "none")
    
    legend.list = list(
      Legend(labels = round(seq(min(df[,"size.by"], na.rm = T), max(df[,"size.by"], na.rm = T), length.out=5), size.by.round), title = size.by,
             graphics = lapply(c(.01, .25, .5, .75, 1), function(p) 
               function(x, y, w, h) grid.circle(x = x, y = y, r = p * unit(2, "mm"), gp = gpar(fill = "black"))),
             direction = "horizontal"))
  } else {
    layer_fun = function(j, i, x, y, w, h, fill) {}
    rect_gp = gpar(col = NA)
    legend.list = list()
  }

  args <- modifyList(modifyList(list(
    cluster_rows = T, 
    cluster_columns = T,
    row_labels=row_labels(rownames(vals)),
    column_labels=column_labels(colnames(vals))), 
    annotations(rownames(vals), colnames(vals))), 
    list(...))
  
  if(!is.null(names(row.order)) & !hasName(args, "row_split")) args$row_split = stack(row.order)[,2]
  if(!is.null(names(column.order)) & !hasName(args, "column_split")) args$column_split = stack(column.order)[,2]

  hm <- do.call(Heatmap,
                modifyList(list(matrix=vals, col=col.fun, name=color.by,
                                row_order=unlist(row.order),
                                column_order=unlist(column.order),
                                rect_gp=rect_gp, 
                                layer_fun=layer_fun), args))

  if(!is.null(size.by)) 
    return(list(hm=hm, legend_list=legend.list))
  return(hm)
}



plot.trait.associations <- function(df, params,
                                    row.by="state", col.by="trait", value.by="tstat", pval.by="adj.pval", 
                                    cols=green2purple,
                                    show.only.significant=T, plot=T, ...) {
  df <- df %>% filter(trait %in% params)
  df$sig <- cut(df[,pval.by], c(-.1, .0001, .001, .01, .05, Inf), c("****","***", "**", "*", ""))
  
  if(show.only.significant)
    df <- df %>% group_by_at(c(row.by)) %>%
      filter(sum(!!sym(pval.by) < .01) > 0) %>%
      ungroup() %>%
      data.frame()
  
  
  vals <- tidyr::pivot_wider(df, id_cols = all_of(row.by), names_from = all_of(col.by), values_from = all_of(value.by), values_fill = NA_real_) %>%
    tibble::column_to_rownames(row.by) %>% dplyr::select(all_of(params)) %>% as.matrix()
  sig <- tidyr::pivot_wider(df, id_cols = all_of(row.by), names_from = all_of(col.by), values_from = "sig", values_fill = "") %>%
    tibble::column_to_rownames(row.by) %>% dplyr::select(all_of(params)) %>% as.matrix()

  v <- max(abs(vals), na.rm = T)
  col.vals <- c(seq(-v, 0, length.out=11), seq(0, v, length.out=11)[-1])
  
  hm <- Heatmap(vals,
                name = value.by,
                col = circlize::colorRamp2(col.vals, cols(length(col.vals))),
                cell_fun = function(j, i, x, y, w, h, fill) grid.text(sig[i,j], x,y),
                cluster_columns = F, clustering_distance_rows = "euclidean",
                show_row_dend = F,
                ...)
  legend <- Legend(title = "adj.pval", pch = c("****","***","**","*"), type = "points", labels = c("<0.0001","<0.001","<0.01", "<0.05"))
  if(!plot)
    return(list(hm=hm, legend=legend))
  draw(hm, annotation_legend_list = list(legend), merge_legend=T)
}



plot.trait.associations.cross.cohort <- function(
    traits, 
    trait.labels = traits, 
    fdr.thr = .01, 
    analysis.order = c("sc","bulk","meta"),
    .data = data,
    ...) {

  df <- py_to_r(.data$uns$trait.analysis$meta.analysis) %>% 
    # Filter for requested traits
    filter(trait %in% traits) %>% 
    dplyr::select(state, trait, 
                  stat_sc=tstat.sc, stat_bulk=tstat.b, stat_meta=z.meta, 
                  adj.pval_sc=adj.pval.sc, adj.pval_bulk=adj.pval.b, adj.pval_meta=adj.pval.meta)  %>%
    
    # Filter only for states with at least one FDR<fdr.thr association across all traits & cohorts
    mutate(keep = if_any(starts_with("adj.pval_"), ~.<fdr.thr)) %>% # significant in sn/bulk/meta
    group_by(state) %>%
    filter(any(keep)) %>% # significant for at least one trait for any of the cohorts
    dplyr::select(-keep) %>%

    # Format dataframe to show stat_(sc|bulk|meta) and adj.pval_(sc|bulk|meta) for each state~trait
    pivot_longer(cols = c(-state,-trait), names_to = "analysis") %>% 
    mutate(group=gsub("_.*","", analysis), analysis=gsub(".*_", "", analysis)) %>% 
    pivot_wider(names_from = group, values_from = value)
  
  df <- df %>% mutate(trait = factor(trait, traits),
                      analysis = factor(analysis, analysis.order),
                      sig = cut(adj.pval, c(-.1, .0001, .001, .01, .05, Inf), c("****","***", "**", "*", "")))
  
  hm <- split(df, df$analysis) %>%
    lapply(., function(.df) {
      
      v <- max(abs(.df$stat), na.rm = T)
      col.vals <- c(seq(-v, 0, length.out=11), seq(0, v, length.out=11)[-1])

      sig <- .df %>% pivot_wider(id_cols = state, names_from = trait, values_from = sig, values_fill = "", names_sort = TRUE) %>%
        column_to_rownames("state")
      
      pivot_wider(.df, id_cols=state, names_from = trait, values_from = stat, names_sort = TRUE) %>% 
        column_to_rownames("state") %>% 
        as.matrix %>% 
        Heatmap(., 
                name = as.character(.df[[1,"analysis"]]),
                cell_fun = function(j, i, x, y, w, h, fill) grid.text(sig[i,j], x,y),
                col = circlize::colorRamp2(col.vals, green2purple(length(col.vals))),
                column_title = .df[[1,"analysis"]], 
                column_labels = trait.labels,
                cluster_columns = FALSE,
                show_row_dend = FALSE,
                row_names_side = "left",
                column_names_rot = 45,
                ...)
    }) %>% `[`(analysis.order)
  
  legend <- Legend(title = "adj.pval", pch = c("****","***","**","*"), type = "points", labels = c("<0.0001","<0.001","<0.01", "<0.05"))
  draw(hm[[1]] + hm[[2]] + hm[[3]], annotation_legend_list = list(legend), merge_legend=T)
}


plot.landscape <- function(
    features,
    embedding = "X_core_phate",
    cols = colorRampPalette(c("#30123BFF", "#4777EFFF", "#1BD0D5FF", "#62FC6BFF", "#D2E935FF", "#FE9B2DFF", "#DB3A07FF")),
    shape.by = NULL,
    size = 2,
    smoothened = TRUE,
    enforce.same.color.scale = TRUE,
    sort.direction = 1,
    legend.position="none",
    show.feature.name = TRUE,
    raster=FALSE,
    ncol=NULL,
    nrow=NULL,
    data. = data) {
  
  if(is.null(features)) {
    features <- data.frame(c=rep(1,nrow(data.)))
    cols <- function(n) rep("black", n)
    smoothened <- FALSE
  } else { if(class(features) == "character")
    features <- data.frame(data.$X, data.$obsm$meta.data, data.$obs) %>% dplyr::select_at(all_of(features))
  }

  if(class(embedding) == "character") {
    embedding.str = embedding
    embedding <- data.$obsm[[embedding]] %>% `colnames<-`(c("x","y"))
    embedding.axes <- colnames(embedding)
  }
  
  df <- data.frame(embedding, features)
  if(!is.null(shape.by))
    df$shape.by = data.$obsm[,shape.by]
  
  if(smoothened) {
    msk <- rownames(df)
    sim <- data.$obsp[[paste0("similarity_", embedding.str)]] %>% 
      `dimnames<-`(list(data.$obs_names, data.$obs_names)) %>% 
      `[`(msk, msk)
    for(p in colnames(features)) {
      if (class(features[,p]) == "numeric")
        df[!is.na(df[, p]), p] <- (sim[!is.na(df[, p]),!is.na(df[, p])] %*% matrix(df[!is.na(df[, p]), p]))
    }
  }
  
  limits <- NULL
  if(enforce.same.color.scale & ncol(features) > 1) {
    cmin <- min(apply(df[,colnames(features)], 1, min, rm.na=T))
    cmax <- max(apply(df[,colnames(features)], 1, max, rm.na=T))
    limits <- c(cmin, cmax)
  }
  
  lapply(1:ncol(features), function(i) {
    if(class(features[,i]) == "numeric")
      colors <- scale_color_gradientn(colors = cols(21), na.value = "lightgrey", limits = limits)
    else
      colors <- scale_color_manual(values=cols(length(unique(features[,i]))))
    
    args <- lapply(list(x="x", y="y", color=colnames(features)[[i]], shape=shape.by), function(x) if (!is.null(x)) sym(x))
    df. <- df
    if (class(features[,i]) == "numeric") 
      df. <- df. %>% arrange(!is.na(!!sym(args$color)), sort.direction*!!sym(args$color))
    
    plt  <- ggplot(df., aes(!!!args))
    
    if(raster) plt <- plt + ggrastr::geom_point_rast(size=size, raster.dpi=600)
    else       plt <- plt + geom_point(size=size)
    
    plt <- plt + colors + theme_embedding + no.labs + 
      scale_y_continuous(expand=expansion(add=.004)) +
      scale_x_continuous(expand=expansion(add=.004)) + 
      theme(legend.position = legend.position,
            panel.background = element_blank())
    
    if(show.feature.name)
      plt <- plt + ggtitle(args$color)
    
    return(plt)
  }) %>% plot_grid(plotlist = ., nrow=nrow, ncol=ncol)
}



plot.landscape.3D <- function(
    features = NULL,
    embedding = "X_all_3d_phate",
    cols = colorRampPalette(c("#30123BFF", "#4777EFFF", "#1BD0D5FF", "#62FC6BFF", "#D2E935FF", "#FE9B2DFF", "#DB3A07FF")),
    shape.by = NULL,
    size = 2,
    smoothened = TRUE,
    enforce.same.color.scale = TRUE,
    sort.direction = 1,
    legend.position="none",
    theta=0,
    phi=0,
    ncol=NULL,
    nrow=NULL,
    data. = data) {
  
  if(is.null(features)) {
    features <- data.frame(c=rep(1,nrow(data.)))
    cols <- function(n) rep("black", n)
    smoothened <- FALSE
  } else { if(class(features) == "character")
    features <- data.frame(data.$X, data.$obsm$meta.data, data.$obs) %>% dplyr::select_at(all_of(features))
  }
  
  if(class(embedding) == "character") {
    embedding.str = embedding
    embedding <- data.$obsm[[embedding]] %>% `colnames<-`(c("x","y","z"))
    embedding.axes <- colnames(embedding)
  }
  
  df <- data.frame(embedding, features)
  if(!is.null(shape.by))
    df$shape.by = data.$obsm[,shape.by]
  
  df <- df %>% filter(!if_all(embedding.axes, is.na))
  if(smoothened) {
    msk <- rownames(df)
    sim <- data.$obsp[[paste0("similarity_", embedding.str)]] %>% 
      `dimnames<-`(list(data.$obs_names, data.$obs_names)) %>% 
      `[`(msk, msk)
    for(p in colnames(features)) {
      if (class(features[,p]) == "numeric")
        df[!is.na(df[, p]), p] <- (sim[!is.na(df[, p]),!is.na(df[, p])] %*% matrix(df[!is.na(df[, p]), p]))
    }
  }
  
  limits <- NULL
  if(enforce.same.color.scale & ncol(features) > 1) {
    cmin <- min(apply(df[,colnames(features)], 1, min, rm.na=T))
    cmax <- max(apply(df[,colnames(features)], 1, max, rm.na=T))
    limits <- c(cmin, cmax)
  }
  
  lapply(1:ncol(features), function(i) {
    
    if(class(features[,i]) == "numeric")
      colors <- scale_color_gradientn(colors = cols(21), na.value = "lightgrey", limits = limits)
    else
      colors <- scale_color_manual(values=cols(length(unique(features[,i]))))

    args <- lapply(list(x="x", y="y",z="z", color=colnames(features)[[i]], shape=shape.by), function(x) if (!is.null(x)) sym(x))
    ggplot(df %>% arrange(!is.na(!!sym(args$color)), sort.direction*!!sym(args$color)), aes(!!!args)) +
      axes_3D(theta=theta, phi=phi) + 
      stat_3D(theta=theta, phi=phi, size=size) + 
      labs_3D() + 
      colors + labs(x=NULL, y=NULL, title=args$color) + 
      theme_classic() + 
      theme(legend.position = legend.position,
            panel.background = element_blank(),
            axis.line = element_blank(), axis.ticks = element_blank(), axis.text = element_blank()
            )
  }) %>% plot_grid(plotlist = ., nrow=nrow, ncol=ncol)
}

plot.dynamics <- function(features, 
                          data. = data, 
                          dynamics = data.$uns$trajectories$palantir$dynamics, 
                          cols = NULL, 
                          facet.by = c("trajectory","feature"), 
                          overlap.pseudotime=NULL, 
                          include.points=FALSE, 
                          label=FALSE, 
                          fold.change=FALSE, 
                          min.point.alpha=.1,
                          legend.position = "right", 
                          scales = "free_x",
                          raster=F, size=1, ...) {
  
  
  if("pandas.core.frame.DataFrame" %in% class(dynamics$fitted.vals))
    dynamics$fitted.vals <- py_to_r(dynamics$fitted.vals)
  
  if("pandas.core.frame.DataFrame" %in% class(dynamics$pred.vals))
    dynamics$pred.vals <- py_to_r(dynamics$pred.vals) 
  
  fits <- dynamics$fitted.vals %>% filter(feature %in% features)
  preds <- dynamics$pred.vals %>% filter(feature %in% features)
  
  
  facet.by = match.arg(facet.by)
  group.by = setdiff(c("trajectory","feature"), facet.by)
  
  groups <- unique(fits[, group.by])
  if(is.null(cols)) {
    cols <- setNames(scales::hue_pal()(length(groups)), groups)
  }
  
  if(fold.change) {
    fits <- fits %>% group_by(trajectory, feature) %>% mutate(across(c(y,fit), ~./.[x == min(x)]))
    preds <- preds %>% group_by(trajectory, feature) %>% mutate(across(c(fit), ~./.[x == min(x)]))
  }
  
  
  ymax <- max(preds$fit+2*preds$se.fit, na.rm = T)
  ymin <- min(preds$fit-2*preds$se.fit, na.rm = T)
  if(include.points) {
    ymax <- max(c(fits$y, ymax), na.rm = T)*1.05
    ymin <- min(c(fits$y, ymin), na.rm = T)*.95
  }

  p <- ggplot(fits) + 
    facet_wrap(paste0("~",facet.by), scales = scales, ...) + 
    scale_x_continuous(expand = c(0,0), labels=function(x) recode(x, `0`="0", `1`="1", .default = as.character(x))) + 
    scale_y_continuous(expand = c(0,0), limits = c(ymin, ymax), labels=function(x) recode(x, `0`="0", `1`="1", .default = as.character(x))) + 
    theme_classic() + 
    theme(strip.background = element_blank(),
          legend.position = legend.position,
          axis.line = element_line())
  
  if(!is.null(overlap.pseudotime)) {
    p <- p + 
      geom_ribbon(aes(x,ymax=ymax,ymin=ymin), 
                  data.frame(x=c(0, overlap.pseudotime), ymax=rep(ymax, 2), ymin=rep(ymin,2)), 
                  fill="black", alpha=.05) + 
      geom_vline(xintercept = overlap.pseudotime, linetype="dashed")
  }
  
  if(include.points) {
    for(g in groups) {
      if(raster)
        p <- p + ggrastr::geom_point_rast(aes(x,y, color=X.weights., alpha=X.weights.), fits[fits[,group.by] == g,], inherit.aes = F, size=size, raster.dpi = 600)
      else
        p <- p + geom_point(aes(x,y, color=X.weights., alpha=X.weights.), fits[fits[,group.by] == g,], inherit.aes = F, size=size)
      
      p <- p + scale_color_gradientn(colors=colorRampPalette(c("white", cols[[g]]))(10)[-1]) + 
        scale_alpha_binned(range=c(min.point.alpha,1), breaks=c(.25, .5, .75, 1), limits=c(0,1)) + 
        labs(color=g, alpha=g)  + 
        new_scale("alpha") + 
        new_scale("color") #+ 
        #guides(color_new=guide_legend(g), alpha_new=guide_legend(g))
    }
  }
  
  for(g in groups) {
    p <- p + geom_ribbon(aes(x, fit, ymin=fit-2*se.fit, ymax=fit+2*se.fit, fill=!!group.by),
                         preds[preds[, group.by] == g,], alpha=.2, color=NA, inherit.aes = F) + 
      geom_line(aes(x, fit, color=!!group.by),
                preds[preds[, group.by] == g,], linewidth=.5, inherit.aes = F) + 
      scale_color_manual(values = cols[[g]]) +
      scale_fill_manual(values = cols[[g]]) + 
      
      new_scale("color") +
      new_scale("fill") #+
      #guides(color_new=guide_legend(g), fill_new=guide_legend(g))
  }

  if(label) {
    p <- p + ggrepel::geom_label_repel(aes(x, fit, label=feature, color=feature), 
                                       fits %>% group_by(feature, trajectory) %>% slice_max(x, n=1),
                                       min.segment.length = unit(0,"pt"), show.legend = F) + 
    scale_color_manual(values = cols)}
  return(p)
}



plot.dynamics.clustered <- function(dynamics, 
                                    bottom.annotation.df, 
                                    cols = colorspace::sequential_hcl(n = 20, palette = "Reds", rev = T),
                                    bot.ann.cols = function(vals) circlize::colorRamp2(seq(min(vals), max(vals), length.out=20), cols),
                                    branch.order = NULL,
                                    mark.rows = NULL,
                                    ...) {

  # Top annotations - pseudotime in branches
  top.ann <- data.frame(name=colnames(dynamics)) %>% 
    tidyr::separate(name, c("trajectory","ps"), "_", remove = F) %>%
    group_by(trajectory) %>%
    mutate(ps = as.numeric(ps),
           ps.text = case_when(row_number() %in% c(1,n()) ~ as.character(round(ps,1)))) %>%
    column_to_rownames("name")
  
  top.ann <- HeatmapAnnotation(a=anno_simple(top.ann$ps, pch = top.ann$ps.text, 
                                             col = circlize::colorRamp2(seq(0, 1, length.out=20), cols)),
                               annotation_name_side = "left",
                               annotation_label = c("Pseudotime"))
  
  column.split = gsub("_.*", "", colnames(dynamics))
  if(!is.null(branch.order))
    column.split = factor(column.split, levels = branch.order)
  
  right_annotation <- NULL
  if(!is.null(mark.rows)) {
    mark.rows <- intersect(mark.rows, rownames(dynamics))
    ids <- which(rownames(dynamics) %in% mark.rows)
    ann <- anno_mark(at = ids, labels = rownames(dynamics)[ids], which = "row")
    right_annotation <- rowAnnotation(named_rows=ann, gp=gpar(fontsize=10, fontface="bold"))
  }
  
  dynamics.heatmap <- Heatmap(
    dynamics,
    cluster_columns = F,
    show_column_names = F,
    
    row_names_side = "left", 
    row_names_gp = grid::gpar(fontsize=8),

    column_split = column.split,
    cluster_column_slices = F,
    
    col = colorRampPalette(c("blue","white","red"))(20),
    top_annotation = top.ann,
    # bottom_annotation = bot.ann,
    right_annotation = right_annotation,
    
    border = T,
    heatmap_legend_param = list(title="scaled dynamics", direction = "horizontal", legend_width = unit(80, "pt")),
    ...)
  
  return(prepare(dynamics.heatmap))
}

cluster.pathways.wrapper <- function(states=NULL, pathways=NULL, cutoff) {
  if(!is.null(states))
    pathways <- lapply(names(states), function(ct) h5read(data.extended, file.path(mapping[[ct]], "pa")) %>%
                         filter(cluster %in% states[[ct]]))
  
  pathways <- lapply(pathways, function(df) df %>% dplyr::select(cluster, everything())) %>%
    do.call(rbind, .) %>%
    rowwise() %>%
    mutate(across(c(GeneRatio, BgRatio), ~eval(parse(text=.))))
  
  grouped.pathways <- pathways %>% group_by(ID, Description) %>%
    summarise(n = n(),
              across(c(Count, GeneRatio, p.adjust), mean),
              geneID = paste(geneID, collapse = "/"),
              clusters = paste(cluster, collapse = "/"),
              .groups = "drop") %>%
    rowwise() %>%
    mutate(geneID = strsplit(geneID, "/")[[1]] %>% unique %>% paste(., collapse = "/"),
           rowname = ID) %>%
    column_to_rownames("rowname")
  
  clustered.pathways <- ClusterPathways(grouped.pathways, 
                                        adjacency.args = list(method="kappa"), 
                                        clustering.args = list(control =list(cutoff = cutoff)),
                                        rank.pathways.args = list(n.select = function(n) 2, attributes = grouped.pathways %>% dplyr::select(GeneRatio)))
  
  
  indicators <- pathways %>% 
    filter(ID %in% grouped.pathways$ID) %>% 
    mutate(v=ifelse(direction == "upregulated", -log10(p.adjust), log10(p.adjust))) %>% 
    tidyr::pivot_wider(id_cols = "ID", names_from = "cluster", values_from = "v") %>% 
    column_to_rownames("ID") %>% 
    `[`(clustered.pathways$membership %>% names,) %>%
    as.matrix()
  
  if(length(unique(clustered.pathways$membership)) == 1) {
    ord <- data.frame(rows=1:nrow(indicators), membership = 1)
  } else {
    ord <- Heatmap(indicators %>% replace(is.na(.), 0), 
                   row_split = clustered.pathways$membership, 
                   cluster_columns = F) %>% 
      prepare %>% row_order() %>% stack() %>% dplyr::select(rows=values, membership=ind)
  }
  
  return(list(pathways=pathways, grouped.pathways=grouped.pathways, clustered.pathways=clustered.pathways, indicators=indicators, ord=ord))
}

